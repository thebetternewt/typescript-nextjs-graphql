import { BaseVisitor } from './base-visitor';
import * as autoBind from 'auto-bind';
import { DEFAULT_SCALARS } from './scalars';
import { DeclarationBlock, indent, getBaseTypeNode, buildScalars, getConfigValue, getBaseType, getRootTypeNames, stripMapperTypeInterpolation } from './utils';
import { isObjectType, isInterfaceType, isNonNullType, isListType, isUnionType, } from 'graphql';
import { GraphQLObjectType } from 'graphql';
import { OperationVariablesToObject } from './variables-to-object';
import { parseMapper, transformMappers } from './mappers';
export class BaseResolversVisitor extends BaseVisitor {
    constructor(rawConfig, additionalConfig, _schema, defaultScalars = DEFAULT_SCALARS) {
        super(rawConfig, {
            contextType: parseMapper(rawConfig.contextType || 'any'),
            rootValueType: parseMapper(rawConfig.rootValueType || '{}'),
            avoidOptionals: getConfigValue(rawConfig.avoidOptionals, false),
            defaultMapper: rawConfig.defaultMapper ? parseMapper(rawConfig.defaultMapper || 'any') : null,
            mappers: transformMappers(rawConfig.mappers || {}),
            ...(additionalConfig || {}),
        }, buildScalars(_schema, defaultScalars));
        this._schema = _schema;
        this._declarationBlockConfig = {};
        this._collectedResolvers = {};
        this._collectedDirectiveResolvers = {};
        this._usedMappers = {};
        this._resolversTypes = {};
        this._rootTypeNames = [];
        autoBind(this);
        this._rootTypeNames = getRootTypeNames(_schema);
        this._variablesTransfomer = new OperationVariablesToObject(this.scalars, this.convertName);
        this.createResolversFields();
    }
    createResolversFields() {
        const allSchemaTypes = this._schema.getTypeMap();
        this._resolversTypes = Object.keys(allSchemaTypes).reduce((prev, typeName) => {
            if (typeName.startsWith('__')) {
                return prev;
            }
            let shouldApplyOmit = false;
            const isRootType = this._rootTypeNames.includes(typeName);
            const isMapped = this.config.mappers[typeName];
            const isScalar = this.config.scalars[typeName];
            const hasDefaultMapper = !!(this.config.defaultMapper && this.config.defaultMapper.type);
            const schemaType = allSchemaTypes[typeName];
            if (isRootType) {
                prev[typeName] = this.config.rootValueType.type;
                return prev;
            }
            else if (isMapped && this.config.mappers[typeName].type) {
                this.markMapperAsUsed(typeName);
                prev[typeName] = this.config.mappers[typeName].type;
            }
            else if (hasDefaultMapper && !hasPlaceholder(this.config.defaultMapper.type)) {
                prev[typeName] = this.config.defaultMapper.type;
            }
            else if (isScalar) {
                prev[typeName] = this._getScalar(typeName);
            }
            else if (isUnionType(schemaType)) {
                prev[typeName] = schemaType
                    .getTypes()
                    .map(type => this.getTypeToUse(type.name))
                    .join(' | ');
            }
            else {
                shouldApplyOmit = true;
                prev[typeName] = this.convertName(typeName);
            }
            if ((shouldApplyOmit && prev[typeName] !== 'any' && isObjectType(schemaType)) || (isInterfaceType(schemaType) && !isMapped)) {
                const fields = schemaType.getFields();
                const relevantFields = Object.keys(fields)
                    .map(fieldName => {
                    const field = fields[fieldName];
                    const baseType = getBaseType(field.type);
                    if (!this.config.mappers[baseType.name]) {
                        return null;
                    }
                    const addOptionalSign = !this.config.avoidOptionals && !isNonNullType(field.type);
                    return {
                        addOptionalSign,
                        fieldName,
                        replaceWithType: this.wrapTypeWithModifiers(this.getTypeToUse(baseType.name), field.type),
                    };
                })
                    .filter(a => a);
                if (relevantFields.length > 0) {
                    prev[typeName] = this.replaceFieldsInType(prev[typeName], relevantFields);
                }
            }
            if (isMapped && hasPlaceholder(prev[typeName])) {
                prev[typeName] = replacePlaceholder(prev[typeName], typeName);
            }
            if (!isMapped && hasDefaultMapper && hasPlaceholder(this.config.defaultMapper.type)) {
                const name = isScalar ? this._getScalar(typeName) : prev[typeName];
                prev[typeName] = replacePlaceholder(this.config.defaultMapper.type, name);
            }
            return prev;
        }, {});
    }
    replaceFieldsInType(typeName, relevantFields) {
        return `Omit<${typeName}, ${relevantFields.map(f => `'${f.fieldName}'`).join(' | ')}> & { ${relevantFields.map(f => `${f.fieldName}${f.addOptionalSign ? '?' : ''}: ${f.replaceWithType}`).join(', ')} }`;
    }
    applyMaybe(str) {
        return `Maybe<${str}>`;
    }
    clearMaybe(str) {
        if (str.startsWith('Maybe')) {
            return str.replace(/Maybe<(.*?)>$/, '$1');
        }
        return str;
    }
    wrapTypeWithModifiers(baseType, type) {
        if (isNonNullType(type)) {
            return this.clearMaybe(this.wrapTypeWithModifiers(baseType, type.ofType));
        }
        else if (isListType(type)) {
            const innerType = this.wrapTypeWithModifiers(baseType, type.ofType);
            return this.applyMaybe(`Array<${innerType}>`);
        }
        else {
            return this.applyMaybe(baseType);
        }
    }
    buildResolversTypes() {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName('ResolversTypes'))
            .withComment('Mapping between all available schema types and the resolvers types')
            .withBlock(Object.keys(this._resolversTypes)
            .map(typeName => indent(`${typeName}: ${this._resolversTypes[typeName]},`))
            .join('\n')).string;
    }
    get schema() {
        return this._schema;
    }
    get defaultMapperType() {
        return this.config.defaultMapper.type;
    }
    get unusedMappers() {
        return Object.keys(this.config.mappers).filter(name => !this._usedMappers[name]);
    }
    get mappersImports() {
        const groupedMappers = {};
        Object.keys(this.config.mappers)
            .filter(gqlTypeName => this.config.mappers[gqlTypeName].isExternal)
            .forEach(gqlTypeName => {
            const mapper = this.config.mappers[gqlTypeName];
            if (!groupedMappers[mapper.source]) {
                groupedMappers[mapper.source] = [];
            }
            const identifier = stripMapperTypeInterpolation(mapper.type);
            if (!groupedMappers[mapper.source].includes(identifier)) {
                groupedMappers[mapper.source].push(identifier);
            }
        });
        if (this.config.contextType.isExternal) {
            if (!groupedMappers[this.config.contextType.source]) {
                groupedMappers[this.config.contextType.source] = [];
            }
            groupedMappers[this.config.contextType.source].push(this.config.contextType.type);
        }
        if (this.config.rootValueType.isExternal) {
            if (!groupedMappers[this.config.rootValueType.source]) {
                groupedMappers[this.config.rootValueType.source] = [];
            }
            groupedMappers[this.config.rootValueType.source].push(this.config.rootValueType.type);
        }
        if (this.config.defaultMapper && this.config.defaultMapper.isExternal) {
            if (!groupedMappers[this.config.defaultMapper.source]) {
                groupedMappers[this.config.defaultMapper.source] = [];
            }
            const identifier = stripMapperTypeInterpolation(this.config.defaultMapper.type);
            groupedMappers[this.config.defaultMapper.source].push(identifier);
        }
        return Object.keys(groupedMappers).map(source => this.buildMapperImport(source, groupedMappers[source]));
    }
    buildMapperImport(source, types) {
        return `import { ${types.join(', ')} } from '${source}';`;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setVariablesTransformer(variablesTransfomer) {
        this._variablesTransfomer = variablesTransfomer;
    }
    getRootResolver() {
        const name = this.convertName('Resolvers');
        const contextType = `<ContextType = ${this.config.contextType.type}>`;
        // This is here because we don't want to break IResolvers, so there is a mapping by default,
        // and if the developer is overriding typesPrefix, it won't get generated at all.
        const deprecatedIResolvers = !this.config.typesPrefix
            ? `
/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
*/
export type IResolvers${contextType} = ${name}<ContextType>;`
            : '';
        return [
            new DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind('type')
                .withName(name, contextType)
                .withBlock(Object.keys(this._collectedResolvers)
                .map(schemaTypeName => {
                const resolverType = this._collectedResolvers[schemaTypeName];
                return indent(this.formatRootResolver(schemaTypeName, resolverType));
            })
                .join('\n')).string,
            deprecatedIResolvers,
        ].join('\n');
    }
    formatRootResolver(schemaTypeName, resolverType) {
        return `${schemaTypeName}${this.config.avoidOptionals ? '' : '?'}: ${resolverType},`;
    }
    getAllDirectiveResolvers() {
        if (Object.keys(this._collectedDirectiveResolvers).length) {
            const name = this.convertName('DirectiveResolvers');
            const contextType = `<ContextType = ${this.config.contextType.type}>`;
            // This is here because we don't want to break IResolvers, so there is a mapping by default,
            // and if the developer is overriding typesPrefix, it won't get generated at all.
            const deprecatedIResolvers = !this.config.typesPrefix
                ? `
/**
* @deprecated
* Use "DirectiveResolvers" root object instead. If you wish to get "IDirectiveResolvers", add "typesPrefix: I" to your config.
*/
export type IDirectiveResolvers${contextType} = ${name}<ContextType>;`
                : '';
            return [
                new DeclarationBlock(this._declarationBlockConfig)
                    .export()
                    .asKind('type')
                    .withName(name, contextType)
                    .withBlock(Object.keys(this._collectedDirectiveResolvers)
                    .map(schemaTypeName => {
                    const resolverType = this._collectedDirectiveResolvers[schemaTypeName];
                    return indent(this.formatRootResolver(schemaTypeName, resolverType));
                })
                    .join('\n')).string,
                deprecatedIResolvers,
            ].join('\n');
        }
        return '';
    }
    Name(node) {
        return node.value;
    }
    ListType(node) {
        const asString = node.type;
        return `Array<${asString}>`;
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    NamedType(node) {
        const nameStr = node.name;
        if (this.config.scalars[nameStr]) {
            return this._getScalar(nameStr);
        }
        return this.convertName(node);
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    markMapperAsUsed(name) {
        this._usedMappers[name] = true;
    }
    getTypeToUse(name) {
        const resolversType = this.convertName('ResolversTypes');
        return `${resolversType}['${name}']`;
    }
    FieldDefinition(node, key, parent) {
        const hasArguments = node.arguments && node.arguments.length > 0;
        return (parentName) => {
            const original = parent[key];
            const baseType = getBaseTypeNode(original.type);
            const realType = baseType.name.value;
            const typeToUse = this.getTypeToUse(realType);
            const mappedType = this._variablesTransfomer.wrapAstTypeWithModifiers(typeToUse, original.type);
            const subscriptionType = this._schema.getSubscriptionType();
            const isSubscriptionType = subscriptionType && subscriptionType.name === parentName;
            return indent(`${node.name}${this.config.avoidOptionals ? '' : '?'}: ${isSubscriptionType ? 'SubscriptionResolver' : 'Resolver'}<${mappedType}, ParentType, ContextType${hasArguments
                ? `, ${this.convertName(parentName, {
                    useTypesPrefix: true,
                }) +
                    this.convertName(node.name, {
                        useTypesPrefix: false,
                    }) +
                    'Args'}`
                : ''}>,`);
        };
    }
    ObjectTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const type = this.getTypeToUse(node.name);
        const block = new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ParentType = ${type}>`)
            .withBlock(node.fields.map((f) => f(node.name)).join('\n'));
        this._collectedResolvers[node.name] = name + '<ContextType>';
        return block.string;
    }
    UnionTypeDefinition(node, key, parent) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const originalNode = parent[key];
        const possibleTypes = originalNode.types
            .map(node => node.name.value)
            .map(f => `'${f}'`)
            .join(' | ');
        this._collectedResolvers[node.name] = name;
        const type = this.getTypeToUse(node.name);
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ParentType = ${type}>`)
            .withBlock(indent(`__resolveType: TypeResolveFn<${possibleTypes}, ParentType, ContextType>`)).string;
    }
    ScalarTypeDefinition(node) {
        const nameAsString = node.name;
        const baseName = this.getTypeToUse(nameAsString);
        this._collectedResolvers[node.name] = 'GraphQLScalarType';
        return new DeclarationBlock({
            ...this._declarationBlockConfig,
            blockTransformer(block) {
                return block;
            },
        })
            .export()
            .asKind('interface')
            .withName(this.convertName(node, {
            suffix: 'ScalarConfig',
        }), ` extends GraphQLScalarTypeConfig<${baseName}, any>`)
            .withBlock(indent(`name: '${node.name}'`)).string;
    }
    DirectiveDefinition(node) {
        const directiveName = this.convertName(node, {
            suffix: 'DirectiveResolver',
        });
        const hasArguments = node.arguments && node.arguments.length > 0;
        const directiveArgs = hasArguments ? this._variablesTransfomer.transform(node.arguments) : '';
        this._collectedDirectiveResolvers[node.name] = directiveName + '<any, any, ContextType>';
        return new DeclarationBlock({
            ...this._declarationBlockConfig,
            blockTransformer(block) {
                return block;
            },
        })
            .export()
            .asKind('type')
            .withName(directiveName, `<Result, Parent, ContextType = ${this.config.contextType.type}, Args = { ${directiveArgs} }>`)
            .withContent(`DirectiveResolverFn<Result, Parent, ContextType, Args>`).string;
    }
    InterfaceTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const allTypesMap = this._schema.getTypeMap();
        const implementingTypes = [];
        this._collectedResolvers[node.name] = name;
        for (const graphqlType of Object.values(allTypesMap)) {
            if (graphqlType instanceof GraphQLObjectType) {
                const allInterfaces = graphqlType.getInterfaces();
                if (allInterfaces.find(int => int.name === node.name)) {
                    implementingTypes.push(graphqlType.name);
                }
            }
        }
        const type = this.getTypeToUse(node.name);
        const possibleTypes = implementingTypes.map(name => `'${name}'`).join(' | ') || 'null';
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<ContextType = ${this.config.contextType.type}, ParentType = ${type}>`)
            .withBlock([indent(`__resolveType: TypeResolveFn<${possibleTypes}, ParentType, ContextType>,`), ...(node.fields || []).map((f) => f(node.name))].join('\n')).string;
    }
    SchemaDefinition() {
        return null;
    }
}
function replacePlaceholder(pattern, typename) {
    return pattern.replace('{T}', typename);
}
function hasPlaceholder(pattern) {
    return pattern.includes('{T}');
}
//# sourceMappingURL=base-resolvers-visitor.js.map