import { Kind, isObjectType, isUnionType, isInterfaceType, isEnumType, SchemaMetaFieldDef, TypeMetaFieldDef, isScalarType, } from 'graphql';
import { getBaseType, quoteIfNeeded, isRootType } from './utils';
function isMetadataFieldName(name) {
    return ['__schema', '__type'].includes(name);
}
const metadataFieldMap = {
    __schema: SchemaMetaFieldDef,
    __type: TypeMetaFieldDef,
};
export class SelectionSetToObject {
    constructor(_scalars, _schema, _convertName, _addTypename, _loadedFragments, _parentSchemaType, _selectionSet) {
        this._scalars = _scalars;
        this._schema = _schema;
        this._convertName = _convertName;
        this._addTypename = _addTypename;
        this._loadedFragments = _loadedFragments;
        this._parentSchemaType = _parentSchemaType;
        this._selectionSet = _selectionSet;
        this._primitiveFields = [];
        this._primitiveAliasedFields = [];
        this._linksFields = [];
        this._fragments = {};
        this._queriedForTypename = false;
    }
    createNext(parentSchemaType, selectionSet) {
        throw new Error(`You must override createNext in your SelectionSetToObject implementation!`);
    }
    wrapTypeWithModifiers(baseType, type) {
        throw new Error(`You must override wrapTypeWithModifiers in your SelectionSetToObject implementation!`);
    }
    _collectField(field) {
        if (field.name.value === '__typename') {
            this._queriedForTypename = true;
            return;
        }
        if (isObjectType(this._parentSchemaType) || isInterfaceType(this._parentSchemaType)) {
            let schemaField;
            if (isRootType(this._parentSchemaType, this._schema) && isMetadataFieldName(field.name.value)) {
                schemaField = metadataFieldMap[field.name.value];
            }
            else {
                schemaField = this._parentSchemaType.getFields()[field.name.value];
            }
            const rawType = schemaField.type;
            const baseType = getBaseType(rawType);
            if (!baseType) {
                throw new Error(`Unable to find a type called "${rawType}" in your schema!`);
            }
            const typeName = baseType.name;
            if (this._scalars[typeName] || isEnumType(baseType) || isScalarType(baseType)) {
                if (field.alias && field.alias.value) {
                    this._primitiveAliasedFields.push({
                        fieldName: field.name.value,
                        alias: field.alias.value,
                    });
                }
                else {
                    this._primitiveFields.push(field.name.value);
                }
            }
            else {
                const selectionSetToObject = this.createNext(baseType, field.selectionSet);
                this._linksFields.push({
                    alias: field.alias ? field.alias.value : null,
                    name: field.name.value,
                    type: typeName,
                    selectionSet: this.wrapTypeWithModifiers(selectionSetToObject.string, rawType),
                });
            }
        }
    }
    _collectFragmentSpread(node) {
        const loadedFragment = this._loadedFragments.find(f => f.name === node.name.value);
        if (!loadedFragment) {
            throw new Error(`Unable to find fragment matching then name "${node.name.value}"! Please make sure it's loaded.`);
        }
        if (!this._fragments[loadedFragment.onType]) {
            this._fragments[loadedFragment.onType] = [];
        }
        this._fragments[loadedFragment.onType].push(this._convertName(node.name.value, { useTypesPrefix: true, suffix: 'Fragment' }));
    }
    _collectInlineFragment(node) {
        const onType = node.typeCondition.name.value;
        const schemaType = this._schema.getType(onType);
        if (!schemaType) {
            throw new Error(`Inline fragment refernces a GraphQL type "${onType}" that does not exists in your schema!`);
        }
        const selectionSet = this.createNext(schemaType, node.selectionSet);
        if (!this._fragments[onType]) {
            this._fragments[onType] = [];
        }
        this._fragments[onType].push(selectionSet.string);
    }
    get string() {
        if (!this._selectionSet || !this._selectionSet.selections || this._selectionSet.selections.length === 0) {
            return '';
        }
        const { selections } = this._selectionSet;
        for (const selection of selections) {
            switch (selection.kind) {
                case Kind.FIELD:
                    this._collectField(selection);
                    break;
                case Kind.FRAGMENT_SPREAD:
                    this._collectFragmentSpread(selection);
                    break;
                case Kind.INLINE_FRAGMENT:
                    this._collectInlineFragment(selection);
                    break;
            }
        }
        const parentName = this._convertName(this._parentSchemaType.name, {
            useTypesPrefix: true,
        });
        const typeName = this._addTypename || this._queriedForTypename ? this.buildTypeNameField() : null;
        const baseFields = this.buildPrimitiveFields(parentName, this._primitiveFields);
        const aliasBaseFields = this.buildAliasedPrimitiveFields(parentName, this._primitiveAliasedFields);
        const linksFields = this.buildLinkFields(this._linksFields);
        const fragments = this.buildFragments(this._fragments);
        const fieldsSet = [typeName, baseFields, aliasBaseFields, linksFields, fragments].filter(f => f && f !== '');
        return this.mergeAllFields(fieldsSet);
    }
    mergeAllFields(fieldsSet) {
        return quoteIfNeeded(fieldsSet, ' & ');
    }
    buildTypeNameField() {
        const possibleTypes = [];
        if (!isUnionType(this._parentSchemaType) && !isInterfaceType(this._parentSchemaType)) {
            possibleTypes.push(this._parentSchemaType.name);
        }
        if (possibleTypes.length === 0) {
            return null;
        }
        return `{ ${this.formatNamedField('__typename')}${this._queriedForTypename ? '' : '?'}: ${possibleTypes.map(t => `'${t}'`).join(' | ')} }`;
    }
    buildPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `Pick<${parentName}, ${fields.map(field => `'${field}'`).join(' | ')}>`;
    }
    buildAliasedPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields.map(aliasedField => `${this.formatNamedField(aliasedField.alias)}: ${parentName}['${aliasedField.fieldName}']`).join(', ')} }`;
    }
    formatNamedField(name) {
        return name;
    }
    buildLinkFields(fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields.map(field => `${this.formatNamedField(field.alias || field.name)}: ${field.selectionSet}`).join(', ')} }`;
    }
    buildFragments(fragments) {
        if (isUnionType(this._parentSchemaType) || isInterfaceType(this._parentSchemaType)) {
            return this._handleFragmentsForUnionAndInterface(fragments);
        }
        else if (isObjectType(this._parentSchemaType)) {
            return this._handleFragmentsForObjectType(fragments);
        }
        return null;
    }
    _handleFragmentsForObjectType(fragments) {
        const fragmentsValue = Object.keys(fragments).reduce((prev, fragmentName) => {
            const fragmentArr = fragments[fragmentName];
            return [...prev, ...fragmentArr];
        }, []);
        return quoteIfNeeded(fragmentsValue, ' & ');
    }
    _handleFragmentsForUnionAndInterface(fragments) {
        const interfaces = {};
        const types = {};
        const onInterfaces = Object.keys(fragments).filter(typeName => isInterfaceType(this._schema.getType(typeName)));
        const onNonInterfaces = Object.keys(fragments).filter(typeName => !isInterfaceType(this._schema.getType(typeName)));
        for (const typeName of onInterfaces) {
            const interfaceFragments = fragments[typeName];
            interfaces[typeName] = {
                fragments: interfaceFragments,
                implementingFragments: [],
            };
        }
        for (const typeName of onNonInterfaces) {
            const schemaType = this._schema.getType(typeName);
            if (!schemaType) {
                throw new Error(`Inline fragment refernces a GraphQL type "${typeName}" that does not exists in your schema!`);
            }
            const typeFragments = fragments[typeName];
            const interfacesFragments = schemaType.getInterfaces === undefined ? [] : schemaType.getInterfaces().filter(gqlInterface => !!interfaces[gqlInterface.name]);
            if (interfacesFragments.length > 0) {
                for (const relevantInterface of interfacesFragments) {
                    interfaces[relevantInterface.name].implementingFragments.push(...typeFragments);
                }
            }
            else {
                types[typeName] = {
                    fragments: typeFragments,
                    implementingFragments: [],
                };
            }
        }
        const mergedResult = { ...interfaces, ...types };
        return quoteIfNeeded(Object.keys(mergedResult).map(typeName => {
            const baseFragments = quoteIfNeeded(mergedResult[typeName].fragments, ' & ');
            const implementingFragments = quoteIfNeeded(mergedResult[typeName].implementingFragments, ' | ');
            return quoteIfNeeded([baseFragments, implementingFragments].filter(a => a), ' & ');
        }), ' | ');
    }
}
//# sourceMappingURL=selection-set-to-object.js.map