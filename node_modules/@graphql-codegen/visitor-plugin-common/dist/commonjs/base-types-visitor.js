"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_visitor_1 = require("./base-visitor");
const mappers_1 = require("./mappers");
const scalars_1 = require("./scalars");
const utils_1 = require("./utils");
const variables_to_object_1 = require("./variables-to-object");
class BaseTypesVisitor extends base_visitor_1.BaseVisitor {
    constructor(_schema, rawConfig, additionalConfig, defaultScalars = scalars_1.DEFAULT_SCALARS) {
        super(rawConfig, {
            enumValues: rawConfig.enumValues || {},
            ...additionalConfig,
        }, utils_1.buildScalars(_schema, defaultScalars));
        this._schema = _schema;
        this._argumentsTransformer = new variables_to_object_1.OperationVariablesToObject(this.scalars, this.convertName);
    }
    get scalarsDefinition() {
        const allScalars = Object.keys(this.config.scalars).map(scalarName => {
            const scalarValue = this.config.scalars[scalarName];
            const scalarType = this._schema.getType(scalarName);
            const comment = scalarType && scalarType.astNode && scalarType.description ? utils_1.transformComment(scalarType.description, 1) : '';
            return comment + utils_1.indent(`${scalarName}: ${scalarValue},`);
        });
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName('Scalars')
            .withComment('All built-in and custom scalars, mapped to their actual values')
            .withBlock(allScalars.join('\n')).string;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setArgumentsTransformer(argumentsTransfomer) {
        this._argumentsTransformer = argumentsTransfomer;
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    InputObjectTypeDefinition(node) {
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withBlock(node.fields.join('\n')).string;
    }
    InputValueDefinition(node) {
        const comment = utils_1.transformComment(node.description, 1);
        return comment + utils_1.indent(`${node.name}: ${node.type},`);
    }
    Name(node) {
        return node.value;
    }
    FieldDefinition(node) {
        const typeString = node.type;
        const comment = utils_1.transformComment(node.description, 1);
        return comment + utils_1.indent(`${node.name}: ${typeString},`);
    }
    UnionTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const possibleTypes = originalNode.types.map(t => (this.scalars[t.name.value] ? this._getScalar(t.name.value) : this.convertName(t))).join(' | ');
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withContent(possibleTypes).string;
    }
    ObjectTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const interfaces = originalNode.interfaces && node.interfaces.length > 0 ? originalNode.interfaces.map(i => this.convertName(i)).join(' & ') + (node.fields.length ? ' & ' : '') : '';
        const typeDefinition = new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withContent(interfaces)
            .withComment(node.description)
            .withBlock(node.fields.join('\n')).string;
        const argumentsBlock = this.buildArgumentsBlock(originalNode);
        return [typeDefinition, argumentsBlock].filter(f => f).join('\n\n');
    }
    InterfaceTypeDefinition(node, key, parent) {
        const argumentsBlock = this.buildArgumentsBlock(parent[key]);
        const interfaceDefinition = new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withBlock(node.fields.join('\n')).string;
        return [interfaceDefinition, argumentsBlock].filter(f => f).join('\n\n');
    }
    ScalarTypeDefinition(node) {
        // We empty this because we handle scalars in a different way, see constructor.
        return '';
    }
    _buildEnumImport(identifier, source) {
        return `import { ${identifier} } from '${source}';`;
    }
    getEnumsImports() {
        return Object.keys(this.config.enumValues)
            .map(enumName => {
            const mappedValue = this.config.enumValues[enumName];
            if (mappedValue && typeof mappedValue === 'string') {
                const mapper = mappers_1.parseMapper(mappedValue);
                if (mapper.isExternal) {
                    const identifier = mapper.type === enumName ? enumName : `${mapper.type} as ${enumName}`;
                    return this._buildEnumImport(identifier, mapper.source);
                }
            }
            return null;
        })
            .filter(a => a)
            .join('\n');
    }
    EnumTypeDefinition(node) {
        const enumName = node.name;
        // In case of mapped external enum string
        if (this.config.enumValues[enumName] && typeof this.config.enumValues[enumName] === 'string') {
            return null;
        }
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('enum')
            .withName(this.convertName(node))
            .withComment(node.description)
            .withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
    }
    // We are using it in order to transform "description" field
    StringValue(node) {
        return node.value;
    }
    buildEnumValuesBlock(typeName, values) {
        return values
            .map(enumOption => {
            const optionName = this.convertName(enumOption, { useTypesPrefix: false, transformUnderscore: true });
            const comment = utils_1.transformComment(enumOption.description, 1);
            let enumValue = enumOption.name;
            if (this.config.enumValues[typeName] && typeof this.config.enumValues[typeName] === 'object' && this.config.enumValues[typeName][enumValue]) {
                enumValue = this.config.enumValues[typeName][enumValue];
            }
            return comment + utils_1.indent(`${optionName}${this._declarationBlockConfig.enumNameValueSeparator} ${utils_1.wrapWithSingleQuotes(enumValue)}`);
        })
            .join(',\n');
    }
    DirectiveDefinition(node) {
        return '';
    }
    buildArgumentsBlock(node) {
        const fieldsWithArguments = node.fields.filter(field => field.arguments && field.arguments.length > 0) || [];
        return fieldsWithArguments
            .map(field => {
            const name = node.name.value +
                this.convertName(field, {
                    useTypesPrefix: false,
                }) +
                'Args';
            return new utils_1.DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind('type')
                .withName(this.convertName(name))
                .withComment(node.description)
                .withBlock(this._argumentsTransformer.transform(field.arguments)).string;
        })
            .join('\n\n');
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    _getTypeForNode(node) {
        const typeAsString = node.name;
        if (this.scalars[typeAsString]) {
            return this._getScalar(typeAsString);
        }
        return this.convertName(node);
    }
    NamedType(node) {
        return this._getTypeForNode(node);
    }
    ListType(node) {
        const asString = node.type;
        return this.wrapWithListType(asString);
    }
    SchemaDefinition() {
        return null;
    }
    wrapWithListType(str) {
        return `Array<${str}>`;
    }
}
exports.BaseTypesVisitor = BaseTypesVisitor;
//# sourceMappingURL=base-types-visitor.js.map