import { ParsedConfig, RawConfig, BaseVisitor } from './base-visitor';
import { ScalarsMap } from './types';
import { DeclarationBlockConfig } from './utils';
import { NameNode, ListTypeNode, NamedTypeNode, FieldDefinitionNode, ObjectTypeDefinitionNode, GraphQLSchema, NonNullTypeNode, UnionTypeDefinitionNode, ScalarTypeDefinitionNode, InterfaceTypeDefinitionNode } from 'graphql';
import { DirectiveDefinitionNode, GraphQLOutputType } from 'graphql';
import { OperationVariablesToObject } from './variables-to-object';
import { ParsedMapper } from './mappers';
export interface ParsedResolversConfig extends ParsedConfig {
    contextType: ParsedMapper;
    rootValueType: ParsedMapper;
    mappers: {
        [typeName: string]: ParsedMapper;
    };
    defaultMapper: ParsedMapper | null;
    avoidOptionals: boolean;
}
export interface RawResolversConfig extends RawConfig {
    /**
     * @name contextType
     * @type string
     * @description Use this configuration to set a custom type for your `context`, and it will
     * effect all the resolvers, without the need to override it using generics each time.
     * If you wish to use an external type and import it from another file, you can use `add` plugin
     * and add the required `import` statement, or you can use a `module#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: MyContext
     * ```
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: ./my-types#MyContext
     * ```
     */
    contextType?: string;
    /**
     * @name rootValueType
     * @type string
     * @description Use this configuration to set a custom type for the `rootValue`, and it will
     * effect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.
     * If you wish to use an external type and import it from another file, you can use `add` plugin
     * and add the required `import` statement, or you can use a `module#type` syntax.
     *
     * @example Custom RootValue Type
     * ```yml
     * plugins
     *   config:
     *     rootValueType: MyRootValue
     * ```
     * @example Custom RootValue Type
     * ```yml
     * plugins
     *   config:
     *     rootValueType: ./my-types#MyRootValue
     * ```
     */
    rootValueType?: string;
    /**
     * @name mappers
     * @type Object
     * @description Replaces a GraphQL type usage with a custom type, allowing you to return custom object from
     * your resolvers.
     * You can use a `module#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     mappers:
     *       User: ./my-models#UserDbObject
     * ```
     */
    mappers?: {
        [typeName: string]: string;
    };
    /**
     * @name defaultMapper
     * @type string
     * @description Allow you to set the default mapper when it's not being override by `mappers` or generics.
     * You can specify a type name, or specify a string in `module#type` format.
     * The defualt value of mappers it the TypeScript type generated by `typescript` package.
     *
     * @example Replace with any
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: any
     * ```
     *
     * @example Custom Base Object
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: ./my-file#BaseObject
     * ```
     *
     * @example Wrap default types with Partial
     * You can also specify a custom wrapper for the original type, without overring the original generated types, use "{T}" to specify the identifier. (for flow, use `$Shape<{T}>`)
     * ```yml
     * plugins
     *   config:
     *     defaultMapper: Partial<{T}>
     * ```
     */
    defaultMapper?: string;
    /**
     * @name avoidOptionals
     * @type boolean
     * @description This will cause the generator to avoid using TypeScript optionals (`?`),
     * so all field resolvers must be implemented in order to avoid compilation errors.
     *
     * @default false
     *
     * @example
     * ```yml
     * generates:
     * path/to/file.ts:
     *  plugins:
     *    - typescript
     *    - typescript-resolvers
     *  config:
     *    avoidOptionals: true
     * ```
     */
    avoidOptionals?: boolean;
    /**
     * @name showUnusedMappers
     * @type boolean
     * @description Warns about unused mappers.
     * @default true
     *
     * @example
     * ```yml
     * generates:
     * path/to/file.ts:
     *  plugins:
     *    - typescript
     *    - typescript-resolvers
     *  config:
     *    showUnusedMappers: true
     * ```
     */
    showUnusedMappers?: boolean;
}
export declare type ResolverTypes = {
    [gqlType: string]: string;
};
export declare class BaseResolversVisitor<TRawConfig extends RawResolversConfig = RawResolversConfig, TPluginConfig extends ParsedResolversConfig = ParsedResolversConfig> extends BaseVisitor<TRawConfig, TPluginConfig> {
    private _schema;
    protected _parsedConfig: TPluginConfig;
    protected _declarationBlockConfig: DeclarationBlockConfig;
    protected _collectedResolvers: {
        [key: string]: string;
    };
    protected _collectedDirectiveResolvers: {
        [key: string]: string;
    };
    protected _variablesTransfomer: OperationVariablesToObject;
    protected _usedMappers: {
        [key: string]: boolean;
    };
    protected _resolversTypes: ResolverTypes;
    protected _rootTypeNames: string[];
    constructor(rawConfig: TRawConfig, additionalConfig: TPluginConfig, _schema: GraphQLSchema, defaultScalars?: ScalarsMap);
    protected createResolversFields(): void;
    protected replaceFieldsInType(typeName: string, relevantFields: {
        addOptionalSign: boolean;
        fieldName: string;
        replaceWithType: string;
    }[]): string;
    protected applyMaybe(str: string): string;
    protected clearMaybe(str: string): string;
    protected wrapTypeWithModifiers(baseType: string, type: GraphQLOutputType): string;
    buildResolversTypes(): string;
    readonly schema: GraphQLSchema;
    readonly defaultMapperType: string;
    readonly unusedMappers: string[];
    readonly mappersImports: string[];
    protected buildMapperImport(source: string, types: string[]): string;
    setDeclarationBlockConfig(config: DeclarationBlockConfig): void;
    setVariablesTransformer(variablesTransfomer: OperationVariablesToObject): void;
    getRootResolver(): string;
    protected formatRootResolver(schemaTypeName: string, resolverType: string): string;
    getAllDirectiveResolvers(): string;
    Name(node: NameNode): string;
    ListType(node: ListTypeNode): string;
    protected _getScalar(name: string): string;
    NamedType(node: NamedTypeNode): string;
    NonNullType(node: NonNullTypeNode): string;
    protected markMapperAsUsed(name: string): void;
    protected getTypeToUse(name: string): string;
    FieldDefinition(node: FieldDefinitionNode, key: string | number, parent: any): (parentName: string) => string;
    ObjectTypeDefinition(node: ObjectTypeDefinitionNode): string;
    UnionTypeDefinition(node: UnionTypeDefinitionNode, key: string | number, parent: any): string;
    ScalarTypeDefinition(node: ScalarTypeDefinitionNode): string;
    DirectiveDefinition(node: DirectiveDefinitionNode): string;
    InterfaceTypeDefinition(node: InterfaceTypeDefinitionNode): string;
    SchemaDefinition(): any;
}
