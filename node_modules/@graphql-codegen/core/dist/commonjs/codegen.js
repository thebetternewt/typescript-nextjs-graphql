"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const merge_schemas_1 = require("./merge-schemas");
const execute_plugin_1 = require("./execute-plugin");
const errors_1 = require("./errors");
async function codegen(options) {
    let output = '';
    validateDocuments(options.schema, options.documents);
    const pluginPackages = Object.keys(options.pluginMap).map(key => options.pluginMap[key]);
    // merged schema with parts added by plugins
    const schema = pluginPackages.reduce((schema, plugin) => {
        return !plugin.addToSchema ? schema : merge_schemas_1.mergeSchemas([schema, plugin.addToSchema]);
    }, options.schema);
    for (const plugin of options.plugins) {
        const name = Object.keys(plugin)[0];
        const pluginPackage = options.pluginMap[name];
        const pluginConfig = plugin[name];
        const result = await execute_plugin_1.executePlugin({
            name,
            config: typeof pluginConfig !== 'object'
                ? pluginConfig
                : {
                    ...options.config,
                    ...pluginConfig,
                },
            schema,
            documents: options.documents,
            outputFilename: options.filename,
            allPlugins: options.plugins,
        }, pluginPackage);
        output += result;
    }
    return output;
}
exports.codegen = codegen;
function validateDocuments(schema, files) {
    // duplicated names
    const operationMap = {};
    files.forEach(file => {
        graphql_1.visit(file.content, {
            OperationDefinition(node) {
                if (typeof node.name !== 'undefined') {
                    if (!operationMap[node.name.value]) {
                        operationMap[node.name.value] = [];
                    }
                    operationMap[node.name.value].push(file.filePath);
                }
            },
        });
    });
    const names = Object.keys(operationMap);
    if (names.length) {
        const duplicated = names.filter(name => operationMap[name].length > 1);
        if (!duplicated.length) {
            return;
        }
        const list = duplicated
            .map(name => `
      * ${name} found in:
        ${operationMap[name]
            .map(filepath => {
            return `
            - ${filepath}
          `.trimRight();
        })
            .join('')}
  `.trimRight())
            .join('');
        throw new errors_1.DetailedError(`Not all operations have an unique name: ${duplicated.join(', ')}`, `
        Not all operations have an unique name

        ${list}
      `);
    }
}
//# sourceMappingURL=codegen.js.map