import { DetailedError, codegen, mergeSchemas } from '@graphql-codegen/core';
import * as Listr from 'listr';
import { normalizeOutputParam, normalizeInstanceOrArray, normalizeConfig } from './helpers';
import { prettify } from './utils/prettier';
import { Renderer } from './utils/listr-renderer';
import { loadSchema, loadDocuments } from './load';
import { GraphQLError } from 'graphql';
import { getPluginByName } from './plugins';
import { debugLog } from './utils/debugging';
export const defaultPluginLoader = (mod) => import(mod);
export async function executeCodegen(config) {
    function wrapTask(task, source) {
        return async () => {
            try {
                await task();
            }
            catch (error) {
                if (source && !(error instanceof GraphQLError)) {
                    error.source = source;
                }
                throw error;
            }
        };
    }
    const result = [];
    const commonListrOptions = {
        exitOnError: true,
    };
    let listr;
    if (process.env.VERBOSE) {
        listr = new Listr({
            ...commonListrOptions,
            renderer: 'verbose',
            nonTTYRenderer: 'verbose',
        });
    }
    else if (process.env.NODE_ENV === 'test') {
        listr = new Listr({
            ...commonListrOptions,
            renderer: 'silent',
            nonTTYRenderer: 'silent',
        });
    }
    else {
        listr = new Listr({
            ...commonListrOptions,
            renderer: config.silent ? 'silent' : Renderer,
            nonTTYRenderer: config.silent ? 'silent' : 'default',
            collapse: true,
            clearOutput: false,
        });
    }
    let rootConfig = {};
    let rootSchemas;
    let rootDocuments;
    let generates = {};
    async function normalize() {
        /* Load Require extensions */
        const requireExtensions = normalizeInstanceOrArray(config.require);
        for (const mod of requireExtensions) {
            await import(mod);
        }
        /* Root templates-config */
        rootConfig = config.config || {};
        /* Normalize root "schema" field */
        rootSchemas = normalizeInstanceOrArray(config.schema);
        /* Normalize root "documents" field */
        rootDocuments = normalizeInstanceOrArray(config.documents);
        /* Normalize "generators" field */
        const generateKeys = Object.keys(config.generates);
        if (generateKeys.length === 0) {
            throw new DetailedError('Invalid Codegen Configuration!', `
        Please make sure that your codegen config file contains the "generates" field, with a specification for the plugins you need.
        
        It should looks like that:

        schema:
          - my-schema.graphql
        generates:
          my-file.ts:
            - plugin1
            - plugin2
            - plugin3
        `);
        }
        for (const filename of generateKeys) {
            generates[filename] = normalizeOutputParam(config.generates[filename]);
            if (generates[filename].plugins.length === 0) {
                throw new DetailedError('Invalid Codegen Configuration!', `
          Please make sure that your codegen config file has defined plugins list for output "${filename}".
          
          It should looks like that:
  
          schema:
            - my-schema.graphql
          generates:
            my-file.ts:
              - plugin1
              - plugin2
              - plugin3
          `);
            }
        }
        if (rootSchemas.length === 0 && Object.keys(generates).some(filename => generates[filename].schema.length === 0)) {
            throw new DetailedError('Invalid Codegen Configuration!', `
        Please make sure that your codegen config file contains either the "schema" field 
        or every generated file has its own "schema" field.
        
        It should looks like that:
        schema:
          - my-schema.graphql

        or:
        generates:
          path/to/output:
            schema: my-schema.graphql
      `);
        }
    }
    listr.add({
        title: 'Parse configuration',
        task: () => normalize(),
    });
    listr.add({
        title: 'Generate outputs',
        task: () => {
            return new Listr(Object.keys(generates).map((filename, i) => ({
                title: `Generate ${filename}`,
                task: () => {
                    const outputConfig = generates[filename];
                    const outputFileTemplateConfig = outputConfig.config || {};
                    const outputDocuments = [];
                    let outputSchema;
                    const outputSpecificSchemas = normalizeInstanceOrArray(outputConfig.schema);
                    const outputSpecificDocuments = normalizeInstanceOrArray(outputConfig.documents);
                    return new Listr([
                        {
                            title: 'Load GraphQL schemas',
                            task: wrapTask(async () => {
                                debugLog(`[CLI] Loading Schemas`);
                                const allSchemas = [...rootSchemas.map(pointToScehma => loadSchema(pointToScehma, config)), ...outputSpecificSchemas.map(pointToScehma => loadSchema(pointToScehma, config))];
                                if (allSchemas.length > 0) {
                                    outputSchema = await mergeSchemas(await Promise.all(allSchemas));
                                }
                            }, filename),
                        },
                        {
                            title: 'Load GraphQL documents',
                            task: wrapTask(async () => {
                                debugLog(`[CLI] Loading Documents`);
                                const allDocuments = [...rootDocuments, ...outputSpecificDocuments];
                                for (const docDef of allDocuments) {
                                    const documents = await loadDocuments(docDef, config);
                                    if (documents.length > 0) {
                                        outputDocuments.push(...documents);
                                    }
                                }
                            }, filename),
                        },
                        {
                            title: 'Generate',
                            task: wrapTask(async () => {
                                debugLog(`[CLI] Generating output`);
                                const normalizedPluginsArray = normalizeConfig(outputConfig.plugins);
                                const pluginLoader = config.pluginLoader || defaultPluginLoader;
                                const pluginPackages = await Promise.all(normalizedPluginsArray.map(plugin => getPluginByName(Object.keys(plugin)[0], pluginLoader)));
                                const pluginMap = {};
                                pluginPackages.forEach((pluginPackage, i) => {
                                    const plugin = normalizedPluginsArray[i];
                                    const name = Object.keys(plugin)[0];
                                    pluginMap[name] = pluginPackage;
                                });
                                const output = await codegen({
                                    filename,
                                    plugins: normalizedPluginsArray,
                                    schema: outputSchema,
                                    documents: outputDocuments,
                                    config: {
                                        ...rootConfig,
                                        ...outputFileTemplateConfig,
                                    },
                                    pluginMap,
                                });
                                result.push({
                                    filename,
                                    content: await prettify(filename, output),
                                });
                            }, filename),
                        },
                    ], {
                        // it stops when one of tasks failed
                        exitOnError: true,
                    });
                },
            })), {
                // it doesn't stop when one of tasks failed, to finish at least some of outputs
                exitOnError: false,
                // run 4 at once
                concurrent: 4,
            });
        },
    });
    await listr.run();
    return result;
}
//# sourceMappingURL=codegen.js.map