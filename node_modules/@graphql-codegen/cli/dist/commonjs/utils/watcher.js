"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("../codegen");
const helpers_1 = require("../helpers");
const isValidPath = require("is-valid-path");
const isGlob = require("is-glob");
const logSymbols = require("log-symbols");
const debugging_1 = require("./debugging");
const logger_1 = require("./logger");
function log(msg) {
    // double spaces to inline the message with Listr
    logger_1.getLogger().info(`  ${msg}`);
}
function emitWatching() {
    log(`${logSymbols.info} Watching for changes...`);
}
exports.createWatcher = (config, onNext) => {
    debugging_1.debugLog(`[Watcher] Starting watcher...`);
    const files = [];
    const documents = helpers_1.normalizeInstanceOrArray(config.documents);
    const schemas = helpers_1.normalizeInstanceOrArray(config.schema);
    // Add schemas and documents from "generates"
    Object.keys(config.generates)
        .map(filename => helpers_1.normalizeOutputParam(config.generates[filename]))
        .forEach(conf => {
        schemas.push(...helpers_1.normalizeInstanceOrArray(conf.schema));
        documents.push(...helpers_1.normalizeInstanceOrArray(conf.documents));
    });
    if (documents) {
        documents.forEach(doc => {
            if (typeof doc === 'string') {
                files.push(doc);
            }
            else {
                files.push(...Object.keys(doc));
            }
        });
    }
    schemas.forEach((schema) => {
        if (isGlob(schema) || isValidPath(schema)) {
            files.push(schema);
        }
    });
    if (typeof config.watch !== 'boolean') {
        files.push(...helpers_1.normalizeInstanceOrArray(config.watch));
    }
    let watcher;
    const runWatcher = async () => {
        const chokidar = await Promise.resolve().then(() => require('chokidar'));
        emitWatching();
        watcher = chokidar.watch(files, {
            persistent: true,
            ignoreInitial: true,
            followSymlinks: true,
            cwd: process.cwd(),
            disableGlobbing: false,
            usePolling: true,
            interval: 100,
            binaryInterval: 300,
            depth: 99,
            awaitWriteFinish: true,
            ignorePermissionErrors: false,
            atomic: true,
            ignored: Object.keys(config.generates),
        });
        debugging_1.debugLog(`[Watcher] Started`);
        let isShutdown = false;
        const shutdown = async () => {
            isShutdown = true;
            debugging_1.debugLog(`[Watcher] Shutting down`);
            log(`Shutting down watch...`);
            watcher.close();
        };
        // it doesn't matter what has changed, need to run whole process anyway
        watcher.on('all', () => {
            if (!isShutdown) {
                codegen_1.executeCodegen(config)
                    .then(onNext, () => Promise.resolve())
                    .then(() => emitWatching());
            }
        });
        process.once('SIGINT', shutdown);
        process.once('SIGTERM', shutdown);
    };
    // the promise never resolves to keep process running
    return new Promise((_, reject) => {
        codegen_1.executeCodegen(config)
            .then(onNext, () => Promise.resolve())
            .then(runWatcher)
            .catch(err => {
            watcher.close();
            reject(err);
        });
    });
};
//# sourceMappingURL=watcher.js.map