"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("./codegen");
const watcher_1 = require("./utils/watcher");
const file_system_1 = require("./utils/file-system");
const mkdirp_1 = require("mkdirp");
const path_1 = require("path");
const debugging_1 = require("./utils/debugging");
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
async function generate(config, saveToFile = true) {
    async function writeOutput(generationResult) {
        if (!saveToFile) {
            return generationResult;
        }
        await Promise.all(generationResult.map(async (result) => {
            if (!shouldOverwrite(config, result.filename) && file_system_1.fileExists(result.filename)) {
                return;
            }
            const content = result.content || '';
            if (content.length === 0) {
                return;
            }
            const basedir = path_1.dirname(result.filename);
            mkdirp_1.sync(basedir);
            file_system_1.writeSync(result.filename, result.content);
        }));
        return generationResult;
    }
    // watch mode
    if (config.watch) {
        return watcher_1.createWatcher(config, writeOutput);
    }
    const outputFiles = await codegen_1.executeCodegen(config);
    await writeOutput(outputFiles);
    return outputFiles;
}
exports.generate = generate;
function shouldOverwrite(config, outputPath) {
    const globalValue = config.overwrite === undefined ? true : !!config.overwrite;
    const outputConfig = config.generates[outputPath];
    if (!outputConfig) {
        debugging_1.debugLog(`Couldn't find a config of ${outputPath}`);
        return globalValue;
    }
    if (isConfiguredOutput(outputConfig) && typeof outputConfig.overwrite === 'boolean') {
        return outputConfig.overwrite;
    }
    return globalValue;
}
function isConfiguredOutput(output) {
    return typeof output.plugins !== 'undefined';
}
//# sourceMappingURL=generate-and-save.js.map