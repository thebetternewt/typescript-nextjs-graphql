import { get, set } from 'lodash';
import { chainFunctions, asArray } from './helpers';
function resolveRelevantMappings(resolvers, path, allMappings) {
    const splitted = path.split('.');
    if (splitted.length === 2) {
        const typeName = splitted[0];
        const fieldName = splitted[1];
        if (fieldName === '*') {
            return Object.keys(resolvers[typeName])
                .map(field => resolveRelevantMappings(resolvers, `${typeName}.${field}`, allMappings))
                .flat()
                .filter(mapItem => !allMappings[mapItem]);
        }
        else {
            const paths = [];
            if ('subscribe' in resolvers[typeName][fieldName]) {
                paths.push(path + '.subscribe');
            }
            if ('resolve' in resolvers[typeName][fieldName]) {
                paths.push(path + '.resolve');
            }
            if (typeof resolvers[typeName][fieldName] === 'function') {
                paths.push(path);
            }
            return paths;
        }
    }
    else if (splitted.length === 1) {
        const typeName = splitted[0];
        return Object.keys(resolvers[typeName]).map(fieldName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)).flat();
    }
    return [];
}
/**
 * Wraps the resolvers object with the resolvers composition objects.
 * Implemented as a simple and basic middleware mechanism.
 *
 * @param resolvers - resolvers object
 * @param mapping - resolvers composition mapping
 * @hidden
 */
export function composeResolvers(resolvers, mapping = {}) {
    Object.keys(mapping).map((resolverPath) => {
        if (mapping[resolverPath] instanceof Array || typeof mapping[resolverPath] === 'function') {
            const composeFns = mapping[resolverPath];
            const relevantFields = resolveRelevantMappings(resolvers, resolverPath, mapping);
            relevantFields.forEach((path) => {
                const fns = chainFunctions([...asArray(composeFns), () => get(resolvers, path)]);
                set(resolvers, path, fns());
            });
        }
        else {
            Object.keys(mapping[resolverPath]).map(fieldName => {
                const composeFns = mapping[resolverPath][fieldName];
                const relevantFields = resolveRelevantMappings(resolvers, resolverPath + '.' + fieldName, mapping);
                relevantFields.forEach((path) => {
                    const fns = chainFunctions([...asArray(composeFns), () => get(resolvers, path)]);
                    set(resolvers, path, fns());
                });
            });
        }
    });
    return resolvers;
}
//# sourceMappingURL=resolvers-composition.js.map