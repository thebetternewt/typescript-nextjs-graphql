"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const epoxy_1 = require("../../epoxy");
const isGlob = require("is-glob");
const isValidPath = require("is-valid-path");
const graphql_1 = require("graphql");
const glob = require("glob");
const fs_1 = require("fs");
const utils_1 = require("../../utils");
const GQL_EXTENSIONS = ['.graphql', '.graphqls', '.gql'];
const INVALID_SCHEMA_KINDS = [graphql_1.Kind.OPERATION_DEFINITION, graphql_1.Kind.FRAGMENT_DEFINITION];
function isGraphQLFile(globPath) {
    return GQL_EXTENSIONS.some(ext => globPath.endsWith(ext));
}
exports.isGraphQLFile = isGraphQLFile;
async function loadSchemaFile(filepath, options) {
    const content = fs_1.readFileSync(filepath, 'utf-8');
    if (content && content.trim() !== '') {
        if (/^\#.*import /i.test(content.trimLeft())) {
            const { importSchema } = await Promise.resolve().then(() => require('graphql-import'));
            return importSchema(filepath);
        }
        const foundDoc = await utils_1.extractDocumentStringFromCodeFile(new graphql_1.Source(content, filepath), options);
        if (foundDoc) {
            return foundDoc;
        }
        if (isGraphQLFile(filepath)) {
            return content;
        }
    }
    else {
        console['warn'](`Empty schema file found: "${filepath}", skipping...`);
    }
    return null;
}
class SchemaFromTypedefs {
    canHandle(globOrValidPath) {
        return isGlob(globOrValidPath) || isValidPath(globOrValidPath);
    }
    async handle(globPath, options) {
        const globFiles = glob.sync(globPath, { cwd: process.cwd() });
        if (!globFiles || globFiles.length === 0) {
            throw new Error(`Unable to find matching files for glob: ${globPath} in directory: ${process.cwd()}`);
        }
        const filesContent = (await Promise.all(globFiles
            .map(async (filePath) => ({ filePath, content: await loadSchemaFile(filePath, options) }))))
            .filter(file => {
            if (!file.content) {
                return false;
            }
            const node = graphql_1.parse(file.content);
            const invalidSchemaDefinitions = node.definitions.filter(def => INVALID_SCHEMA_KINDS.includes(def.kind));
            if (invalidSchemaDefinitions.length === 0) {
                return true;
            }
            else {
                console['warn'](`File "${file.filePath}" was filtered because it contains an invalid GraphQL schema definition!`);
                return false;
            }
        });
        if (filesContent.length === 0) {
            throw new Error(`All found files for glob expression "${globPath}" are not valid or empty, please check it and try again!`);
        }
        return epoxy_1.mergeTypeDefs(filesContent.map(f => f.content));
    }
}
exports.SchemaFromTypedefs = SchemaFromTypedefs;
//# sourceMappingURL=schema-from-typedefs.js.map