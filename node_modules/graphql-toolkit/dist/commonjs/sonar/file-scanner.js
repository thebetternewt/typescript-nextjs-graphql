"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glob_1 = require("glob");
const glob = require("glob");
const path_1 = require("path");
const fs_1 = require("fs");
const graphql_1 = require("graphql");
const DEFAULT_SCHEMA_EXTENSIONS = ['gql', 'graphql', 'graphqls', 'ts', 'js'];
const DEFAULT_IGNORED_RESOLVERS_EXTENSIONS = ['spec', 'test', 'd'];
const DEFAULT_RESOLVERS_EXTENSIONS = ['ts', 'js'];
function scanForFiles(globStr, globOptions = {}) {
    return glob_1.sync(globStr, Object.assign({ absolute: true }, globOptions));
}
function buildGlob(basePath, extensions, ignoredExtensions = []) {
    return `${basePath}/**/${ignoredExtensions.length > 0 ? `!(${ignoredExtensions.map(e => '*.' + e).join('|')})` : '*'}+(${extensions.map(e => '*.' + e).join('|')})`;
}
function extractExports(fileExport) {
    if (!fileExport) {
        return null;
    }
    if (fileExport.default) {
        if (fileExport.default.resolver || fileExport.default.resolvers || fileExport.default.schema) {
            return fileExport.default.resolver || fileExport.default.resolvers || fileExport.default.schema;
        }
        return fileExport.default;
    }
    if (fileExport.resolver) {
        return fileExport.resolver;
    }
    if (fileExport.resolvers) {
        return fileExport.resolvers;
    }
    if (fileExport.schema) {
        return fileExport.schema;
    }
    return fileExport;
}
const LoadSchemaFilesDefaultOptions = {
    extensions: DEFAULT_SCHEMA_EXTENSIONS,
    useRequire: false,
    requireMethod: null,
    globOptions: {},
};
function loadSchemaFiles(basePath, options = LoadSchemaFilesDefaultOptions) {
    const execOptions = Object.assign({}, LoadSchemaFilesDefaultOptions, options);
    const relevantPaths = scanForFiles(buildGlob(basePath, execOptions.extensions, []), options.globOptions);
    return relevantPaths.map(path => {
        const extension = path_1.extname(path);
        if (extension === '.js' || extension === '.ts' || execOptions.useRequire) {
            const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path);
            const extractedExport = extractExports(fileExports);
            if (extractedExport && extractedExport.kind === 'Document') {
                return graphql_1.print(extractedExport);
            }
            return extractedExport;
        }
        else {
            return fs_1.readFileSync(path, { encoding: 'utf-8' });
        }
    });
}
exports.loadSchemaFiles = loadSchemaFiles;
const LoadResolversFilesDefaultOptions = {
    ignoredExtensions: DEFAULT_IGNORED_RESOLVERS_EXTENSIONS,
    extensions: DEFAULT_RESOLVERS_EXTENSIONS,
    requireMethod: null,
    globOptions: {},
};
function loadResolversFiles(basePath, options = LoadResolversFilesDefaultOptions) {
    const execOptions = Object.assign({}, LoadResolversFilesDefaultOptions, options);
    const relevantPaths = scanForFiles(buildGlob(basePath, execOptions.extensions, execOptions.ignoredExtensions), execOptions.globOptions);
    return relevantPaths.map(path => {
        try {
            const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path);
            return extractExports(fileExports);
        }
        catch (e) {
            throw new Error(`Unable to load resolver file: ${path}, error: ${e}`);
        }
    }).filter(t => t);
}
exports.loadResolversFiles = loadResolversFiles;
function scanForFilesAsync(globStr, globOptions = {}) {
    return new Promise((resolve, reject) => glob(globStr, Object.assign({ absolute: true }, globOptions), (err, matches) => {
        if (err) {
            reject(err);
        }
        resolve(matches);
    }));
}
async function loadSchemaFilesAsync(basePath, options = LoadSchemaFilesDefaultOptions) {
    const execOptions = Object.assign({}, LoadSchemaFilesDefaultOptions, options);
    const relevantPaths = await scanForFilesAsync(buildGlob(basePath, execOptions.extensions, []), options.globOptions);
    const require$ = (path) => Promise.resolve().then(() => require(path));
    return Promise.all(relevantPaths.map(async (path) => {
        const extension = path_1.extname(path);
        if (extension === '.js' || extension === '.ts' || execOptions.useRequire) {
            const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path);
            const extractedExport = extractExports(fileExports);
            if (extractedExport && extractedExport.kind === 'Document') {
                return graphql_1.print(extractedExport);
            }
            return extractedExport;
        }
        else {
            return new Promise((resolve, reject) => {
                fs_1.readFile(path, { encoding: 'utf-8' }, (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    resolve(data);
                });
            });
        }
    }));
}
exports.loadSchemaFilesAsync = loadSchemaFilesAsync;
async function loadResolversFilesAsync(basePath, options = LoadResolversFilesDefaultOptions) {
    const execOptions = Object.assign({}, LoadResolversFilesDefaultOptions, options);
    const relevantPaths = await scanForFilesAsync(buildGlob(basePath, execOptions.extensions, []), options.globOptions);
    const require$ = (path) => Promise.resolve().then(() => require(path));
    return Promise.all(relevantPaths.map(async (path) => {
        try {
            const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path);
            return extractExports(fileExports);
        }
        catch (e) {
            throw new Error(`Unable to load resolver file: ${path}, error: ${e}`);
        }
    }));
}
exports.loadResolversFilesAsync = loadResolversFilesAsync;
//# sourceMappingURL=file-scanner.js.map